package jooq.examples.spring.javaconfig;

import static jooq.examples.generated.tables.Author.AUTHOR;
import static jooq.examples.generated.tables.Book.BOOK;
import static jooq.examples.generated.tables.BookStore.BOOK_STORE;
import static jooq.examples.generated.tables.BookToBookStore.BOOK_TO_BOOK_STORE;
import static org.jooq.impl.DSL.countDistinct;

import java.math.BigInteger;

import org.jooq.DSLContext;
import org.jooq.Record;
import org.jooq.Record3;
import org.jooq.Result;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import jooq.examples.generated.tables.Author;
import jooq.examples.generated.tables.Book;
import jooq.examples.generated.tables.BookStore;
import jooq.examples.generated.tables.BookToBookStore;
import oracle.ucp.UniversalConnectionPoolException;
import oracle.ucp.admin.UniversalConnectionPoolManager;

//TODO custom transaction provider not working and looks like tx mgr is not used
public class JavaConfigExampleMain {

    public static void main(String[] args) throws UniversalConnectionPoolException {
        UniversalConnectionPoolManager ucpm = null;
        try {
            ApplicationContext ctx = new AnnotationConfigApplicationContext(PersistenceContext.class);
            ucpm = ctx.getBean("universalConnectionPoolManager", UniversalConnectionPoolManager.class);

            //Using DSLContext
            DSLContext dsl = ctx.getBean("dsl", org.jooq.impl.DefaultDSLContext.class);
            // All of these tables were generated by jOOQ's code gen
            Book b = BOOK.as("b");
            Author a = AUTHOR.as("a");
            BookStore s = BOOK_STORE.as("s");
            BookToBookStore t = BOOK_TO_BOOK_STORE.as("t");

            Object record = dsl.transactionResult(tx -> dsl.fetchCount(BOOK));
            System.out.println(record);


            Result<Record3<String, String, Integer>> result = dsl.select(a.FIRST_NAME, a.LAST_NAME, countDistinct(s.NAME))
                    .from(a).join(b).on(b.AUTHOR_ID.equal(a.ID))
                    .join(t).on(t.BOOK_ID.eq(b.ID.cast(BigInteger.class)))
                    .join(s).on(t.NAME.eq(s.NAME))
                    .groupBy(a.FIRST_NAME, a.LAST_NAME).orderBy(countDistinct(s.NAME).desc()).fetch();

            System.out.println(result);

          Result<?> resultImpl =  dsl.transactionResult(tx ->
                dsl.select(a.FIRST_NAME, a.LAST_NAME, countDistinct(s.NAME))
                        .from(a).join(b).on(b.AUTHOR_ID.equal(a.ID))
                        .join(t).on(t.BOOK_ID.eq(b.ID.cast(BigInteger.class)))
                        .join(s).on(t.NAME.eq(s.NAME))
                        .groupBy(a.FIRST_NAME, a.LAST_NAME).orderBy(countDistinct(s.NAME).desc()).fetch()
            );
            System.out.println(resultImpl);

            //Using Service, list all beans
            for (String name : ctx.getBeanDefinitionNames()) {
                System.out.println("+++++++++++ " + name);
            }

            Service service = ctx.getBean("serviceImpl", Service.class);
            service.create(6, 4, "One Book 2", 2018, 1, "thanuj");

            //Destroy connection pool
            oracle.ucp.jdbc.PoolDataSource pool = ctx.getBean("dataSource", oracle.ucp.jdbc.PoolDataSource.class);
            ucpm.destroyConnectionPool(pool.getConnectionPoolName());

        } finally {
            for (String name : ucpm.getConnectionPoolNames()) {
                System.out.println("===========================================" + name + "==========================================");
                System.out.println(ucpm.getConnectionPool(name).getStatistics().toString());
                System.out.println("=============================================================================================");
            }
        }

    }
}
