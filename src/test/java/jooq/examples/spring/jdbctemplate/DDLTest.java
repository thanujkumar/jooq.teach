package jooq.examples.spring.jdbctemplate;


import org.jooq.*;
import org.jooq.impl.DSL;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;


import static jooq.examples.generated.Tables.INSERT_TEST;
import static org.jooq.impl.DSL.*;
import static org.jooq.impl.SQLDataType.INTEGER;

@ExtendWith(SpringExtension.class)
@ContextConfiguration("classpath:jooq-spring-jdbc-template.xml")
public class DDLTest {

    private static final Logger log = LoggerFactory.getLogger(DDLTest.class);

    @Autowired
    DSLContext dsl;

    @Autowired
    ApplicationContext context;

    @Test
    @DisplayName("Create Sequence")
    public void createSequenceTestMe() {
        dsl.createSequenceIfNotExists("book_sequence").execute();

        // Cache a number of values for the sequence, typically on a per session basis.
        dsl.alterSequence("book_sequence").cache(200).execute();
        // Specify whether the sequence should cycle when it reaches the MAXVALUE
        dsl.alterSequence("book_sequence").cycle().execute();

        // The MINVALUE from which the sequence should cycle if applicable
        //create.alterSequence("book_sequence").minvalue(1).execute();
        //create.alterSequence("book_sequence".noMinvalue.execute();

        // Let the sequence restart with MINVALUE or with a specific value
        //create.alterSequence("book_sequence").restart().execute();
        //create.alterSequence("book_sequence").restartWith(1).execute();

        // Let the sequence start with a specific value
        //create.alterSequence("book_sequence").startWith(1).execute();

        // Renaming the sequence
        //create.alterSequence("old_sequence").renameTo("new_sequence").execute();
    }

    @Test
    @DisplayName("Create Scalar User Function")
    public void createScalarUserFunctionTestMe() {
        // Create a function that always return 1
        dsl.createOrReplaceFunction("one")
                .returns(INTEGER)
                .as(return_(1))
                .execute();

        Result result = dsl.select(DSL.field("ONE")).from("dual").fetch();
        log.info("\n" + result.toString());

        // Create a function that returns the sum of its inputs
        Parameter<Integer> i1 = DSL.in("i1", INTEGER);
        Parameter<Integer> i2 = DSL.in("i2", INTEGER);

        dsl.createOrReplaceFunction("my_sum")
                .parameters(i1, i2)
                .returns(INTEGER)
                .as(return_(i1.plus(i2)))
                .execute();

        result = dsl.select(function("MY_SUM", Integer.class, DSL.field("5"), DSL.field("6"))).fetch();
        //dsl.select(one(), mySum(1, 2)).fetchOne(); //If code is generated by jooq
        log.info("\n" + result.toString());

        Record2<Integer, Integer> result2 = dsl.select(
                function(name("one"), INTEGER),
                function(name("my_sum"), INTEGER, val(1), val(2))
        ).fetchOne();

        log.info("\n" + result2.toString());
    }

    @Test
    @DisplayName("Create Deterministic User Function")
    public void deterministicFunctionTestMe() {
        dsl.createOrReplaceFunction("fun1").returns(INTEGER).deterministic().as(return_(1)).execute();
        dsl.createOrReplaceFunction("fun2").returns(INTEGER).notDeterministic().as(return_(rand())).execute();

        Record2<Integer, Integer> result = dsl.select(
                function(name("fun1"), INTEGER),
                function(name("fun2"), INTEGER)
        ).fetchOne();

        log.info("\n" + result.toString());
    }

    @Test
    @DisplayName("User Function, Conditional null handling")
    public void onNullInputFunctionTestMe() {
        Parameter<Integer> i1 = in("i1", INTEGER);
        Parameter<Integer> i2 = in("i2", INTEGER);

        // The function always returns NULL if any argument value is NULL
        dsl.createOrReplaceFunction("my_sum2")
                .parameters(i1, i2)
                .returns(INTEGER)
                .returnsNullOnNullInput()
                .as(return_(i1.plus(i2)))
                .execute();
        Result result = dsl.select(function(name("my_sum2"), INTEGER, val(3), val((Integer) null))).fetch();

        log.info("\n" + result);

        result = dsl.select(function(name("my_sum2"), INTEGER, val(3), val(6))).fetch();

        log.info("\n" + result);

    }

}
